1.
Given an integer x, return true if x is a palindrome, and false otherwise.

Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
 
Constraints:

-231 <= x <= 231 - 1
 
Follow up: Could you solve it without converting the integer to a string?

Mode: Easy
Company: Google, Facebook, Amazon, Bloomberg, Adobe

class Solution(object):
    def isPalindrome(self, x):
        if x < 0:
            return False
        reverse = 0
        temporary = x
        while temporary > 0:
            digit = temporary % 10
            reverse = reverse * 10 + digit
            temporary = temporary / 10
        return reverse == x              
       
2.
Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]

Example 2:

Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]

Mode: Easy
Company: Amazon, Microsoft, Adobe, Facebook, TCS

class Solution:
    def reverseString(self, s: List[str]) -> None:
        left = 0
        right = len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
        return s

3.
Given a string s, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

Example 1:

Input: s = "IceCreAm"

Output: "AceCreIm"

Explanation:

The vowels in s are ['I', 'e', 'e', 'A']. On reversing the vowels, s becomes "AceCreIm".

Example 2:

Input: s = "leetcode"

Output: "leotcede"


Constraints:

1 <= s.length <= 3 * 105
s consist of printable ASCII characters.

Mode: Easy
Company: Bloomberg

class Solution(object):
    def reverseVowels(self, s):
        vowels = set('aeiouAEIOU')
        list1 = list(s)
        left = 0
        right = len(s) - 1
        while left < right:
            if list1[left] not in vowels:
                left = left + 1
            if list1[right] not in vowels:
                right = right - 1
            if list1[left] in vowels and list1[right] in vowels:
                list1[left], list1[right] = list1[right], list1[left]
                left = left + 1
                right = right - 1
        return ''.join(list1)

4.
Given a string s, reverse the string according to the following rules:

All the characters that are not English letters remain in the same position.
All the English letters (lowercase or uppercase) should be reversed.
Return s after reversing it.

 

Example 1:

Input: s = "ab-cd"
Output: "dc-ba"
Example 2:

Input: s = "a-bC-dEf-ghIj"
Output: "j-Ih-gfE-dCba"
Example 3:

Input: s = "Test1ng-Leet=code-Q!"
Output: "Qedo1ct-eeLg=ntse-T!"
 

Constraints:

1 <= s.length <= 100
s consists of characters with ASCII values in the range [33, 122].
s does not contain '\"' or '\\'.

Mode: Easy
Company: Amazon

class Solution(object):
    def reverseOnlyLetters(self, s):
        def isletter(ch):
            return ('A' <= ch <= 'Z') or ('a' <= ch <= 'z')
        list1 = list(s)
        left = 0
        right = len(s) - 1
        while left < right:
            if not isletter(list1[left]):
                left = left + 1
            if not isletter(list1[right]):
                right = right - 1
            if isletter(list1[left]) and isletter(list1[right]):
                list1[left], list1[right] = list1[right], list1[left]
                left = left + 1
                right = right - 1
        return ''.join(list1)

5.
Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

Example 1:

Input: s = "leetcode"

Output: 0

Explanation:

The character 'l' at index 0 is the first character that does not occur at any other index.

Example 2:

Input: s = "loveleetcode"

Output: 2

Example 3:

Input: s = "aabb"

Output: -1

Mode: Easy
Company: Amazon, Bloomberg, Apple, Microsoft, Oracle

class Solution(object):
    def firstUniqChar(self, s):
        l = []
        for i in s:
            if i not in l:
                l.append(i)
        for i in l:
            if s.count(i) = 1:
                return s.find(i)
        return -1

6.
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.

Mode: Easy

class Solution(object):
    def strStr(self, haystack, needle):
        if needle == "":
            return 0
        for i in range(len(haystack) + 1 - len(needle)):
            if haystack[i:i+len(needle)] == needle:
                return i
        return -1

7.
Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal substring consisting of non-space characters only.

Example 1:

Input: s = "Hello World"
Output: 5
Explanation: The last word is "World" with length 5.
Example 2:

Input: s = "   fly me   to   the moon  "
Output: 4
Explanation: The last word is "moon" with length 4.
Example 3:

Input: s = "luffy is still joyboy"
Output: 6
Explanation: The last word is "joyboy" with length 6.

Mode: Easy
Company: Amazon, Microsoft

class Solution(object):
    def lengthOfLastWord(self, s):
            count = 0
            for i in range(len(s) - 1, -1, -1):
                if s[i] != " ":
                    count = count + 1
                elif count > 0:
                    return count
            return count

8.
Given two strings s and t, return true if t is an anagram of s, and false otherwise.

Example 1:

Input: s = "anagram", t = "nagaram"

Output: true

Example 2:

Input: s = "rat", t = "car"

Output: false

Mode: Easy

class Solution(object):
    def isAnagram(self, s, t):
        return Counter(s) == Counter(t)

9.
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

Example 1:

Input: s = "abc", t = "ahbgdc"
Output: true
Example 2:

Input: s = "axc", t = "ahbgdc"
Output: false

Mode: Easy
Company: Amazon, Google, Yandex, Adobe

class Solution(object):
    def isSubsequence(self, s, t):
        i = 0 # Pointer for s
        for char in t:
            if i < len(s) and s[i] == char:
                i = i + 1
        return i == len(s)

10.
We define the usage of capitals in a word to be right when one of the following cases holds:

All letters in this word are capitals, like "USA".
All letters in this word are not capitals, like "leetcode".
Only the first letter in this word is capital, like "Google".
Given a string word, return true if the usage of capitals in it is right.

Example 1:

Input: word = "USA"
Output: true
Example 2:

Input: word = "FlaG"
Output: false

Mode: Easy
Company: Google, Amazon

class Solution(object):
    def detectCapitalUse(self, word):
        return (word.istitle() or word.isupper() or word.islower())

11.A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
Example 3:

Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

Mode: Easy
Company: Facebook, Amazon, Microsoft, Apple, Adobe

class Solution(object):
    def isPalindrome(self, s):
        s = s.lower()
        temp = ""
        for char in s:
            if char.isalnum():
                temp = temp + char
        return temp == temp[::-1]

12.
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

Example 1:

Input: nums = [2,2,1]

Output: 1

Example 2:

Input: nums = [4,1,2,1,2]

Output: 4

Example 3:

Input: nums = [1]

Output: 1

Mode: Easy
Company: Amazon, Microsoft, Bloomberg, Google, Adobe

class Solution(object):
    def singleNumber(self, nums):
        s = Counter(nums)
        for i, j in s.items(): # Here, i is word and j is freq.
            if j == 1:
                return i

13.
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2

Mode: Easy

class Solution(object):
    def majorityElement(self, nums):
        temp = Counter(nums)
        n = len(nums)
        for i, j in temp.items():
            if j > n/2:
                return i

14.
Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.

A shift on s consists of moving the leftmost character of s to the rightmost position.

For example, if s = "abcde", then it will be "bcdea" after one shift.

Example 1:

Input: s = "abcde", goal = "cdeab"
Output: true
Example 2:

Input: s = "abcde", goal = "abced"
Output: false

Mode: Easy

class Solution(object):
    def rotateString(self, s, goal):
        if len(s) == len(goal) and goal in (s + s):
            return True
        else:
            return False

15.
Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.

Example 1:

Input: s = "Hello"
Output: "hello"
Example 2:

Input: s = "here"
Output: "here"
Example 3:

Input: s = "LOVELY"
Output: "lovely"

Mode: Easy

class Solution(object):
    def toLowerCase(self, s):
        return s.lower()

16.
A word is considered valid if:

It contains a minimum of 3 characters.
It contains only digits (0-9), and English letters (uppercase and lowercase).
It includes at least one vowel.
It includes at least one consonant.
You are given a string word.

Return true if word is valid, otherwise, return false.

Notes:

'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.
A consonant is an English letter that is not a vowel.

Example 1:

Input: word = "234Adas"

Output: true

Explanation:

This word satisfies the conditions.

Example 2:

Input: word = "b3"

Output: false

Explanation:

The length of this word is fewer than 3, and does not have a vowel.

Example 3:

Input: word = "a3$e"

Output: false

Explanation:

This word contains a '$' character and does not have a consonant.

Mode: Easy

class Solution(object):
    def isValid(self, word):
        countv = 0
        countc = 0
        word = list(word)
        lenn = len(word)
        digits = ['0','1','2','3','4','5','6','7','8','9']
        vowels = ['a','e','i','o','u','A','E','I','O','U']
        
        if lenn < 3:
            return False

        for i in word:
            if i in digits:
                continue # Skip
            elif (65 <= ord(i) <= 90) or (97 <= ord(i) <= 122):
                if i in vowels:
                    countv = countv + 1
                else:
                    countc = countc + 1
            else:
                return False # When it contains special characters like $,%, etc

        if countv >= 1 and countc >= 1:
            return True
        else:
            return False

17.
Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.

You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.

Example 1:

Input: num1 = "11", num2 = "123"
Output: "134"
Example 2:

Input: num1 = "456", num2 = "77"
Output: "533"
Example 3:

Input: num1 = "0", num2 = "0"
Output: "0"

Mode: Easy

class Solution(object):
    def addStrings(self, num1, num2):
        int_num1 = int(num1)
        int_num2 = int(num2)

        result = int_num1 + int_num2

        return str(result)

18.
Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.

Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].

For example, swapping at indices 0 and 2 in "abcd" results in "cbad".

Example 1:

Input: s = "ab", goal = "ba"
Output: true
Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get "ba", which is equal to goal.
Example 2:

Input: s = "ab", goal = "ab"
Output: false
Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in "ba" != goal.
Example 3:

Input: s = "aa", goal = "aa"
Output: true
Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get "aa", which is equal to goal.

Mode: Easy

class Solution(object):
    def buddyStrings(self, s, goal):
        if len(s) != len(goal):
            return False

        if s == goal:
            if len(set(s)) < len(s):
                return True
            else: 
                return False

        diff = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                diff.append(i)

        if len(diff) == 2:
            i, j = diff
            return s[i] == goal[j] and s[j] == goal[i]

        return False

19.
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

Mode: Easy

class Solution(object):
    def longestCommonPrefix(self, strs):
        prefix = ""
        first_string = strs[0]
        for i in range(len(first_string)):
            char = first_string[i]
            for other_string in strs[1:]:
                if i >= len(other_string) or other_string[i] != char:
                    return prefix
            prefix = prefix + char
        return prefix

20.
Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 
Example 1:

Input: columnNumber = 1
Output: "A"
Example 2:

Input: columnNumber = 28
Output: "AB"
Example 3:

Input: columnNumber = 701
Output: "ZY"

Mode: Easy

class Solution(object):
    def convertToTitle(self, columnNumber):
        temp = ""
        n = columnNumber
        while n > 0:
            n = n - 1
            rem = n % 26
            temp = temp + chr(ord("A") + rem)
            n = n // 26
        return temp[::-1]

21.
Given an integer num, return a string of its base 7 representation.

Example 1:

Input: num = 100
Output: "202"
Example 2:

Input: num = -7
Output: "-10"

Mode: Easy

class Solution(object):
    def convertToBase7(self, num):
        if num == 0:
            return "0"

        is_negative = num < 0
        if is_negative:
            num = -num

        digits = []
        
        while num > 0:
            rem = num % 7
            digits.append(str(rem))
            num = num // 7
        
        base7 = ''.join(reversed(digits))
        
        if is_negative:
            base7 = '-' + base7
        
        return base7

22.
You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.
Example 2:

Input: s = "", t = "y"
Output: "y"

Mode: Easy

class Solution(object):
    def findTheDifference(self, s, t):
        sum_s = 0
        sum_t = 0
        asc_s = 0
        asc_t = 0
        list_s = list(s)
        list_t = list(t)
        if s == "":
            return t 

        for i in list_s:
            asc_s = asc_s + ord(i)
        for j in list_t:
            asc_t = asc_t + ord(j)

        if asc_s < asc_t:
            return chr(asc_t - asc_s)

23.
Given a string s, return the number of segments in the string.

A segment is defined to be a contiguous sequence of non-space characters.

Example 1:

Input: s = "Hello, my name is John"
Output: 5
Explanation: The five segments are ["Hello,", "my", "name", "is", "John"]
Example 2:

Input: s = "Hello"
Output: 1

Mode: Easy

class Solution(object):
    def countSegments(self, s):
        segments = s.split()
        return len(segments)

24.
Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.

Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

A prefix of a string s is any leading contiguous substring of s.

Example 1:

Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.
Example 2:

Input: sentence = "this problem is an easy problem", searchWord = "pro"
Output: 2
Explanation: "pro" is prefix of "problem" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.
Example 3:

Input: sentence = "i am tired", searchWord = "you"
Output: -1
Explanation: "you" is not a prefix of any word in the sentence.

Mode: Easy

class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):
        words = sentence.split()
        for idx, word in enumerate(words): # Loops through each word by keeting a track of their corresponding indexes as idx here
            if word.startswith(searchWord):
                return idx + 1  # 1-based index
        return -1

25.
Given an integer n, add a dot (".") as the thousands separator and return it in string format.

Example 1:

Input: n = 987
Output: "987"
Example 2:

Input: n = 1234
Output: "1.234"

Mode: Easy

class Solution(object):
    def thousandSeparator(self, n):
        sn = str(n)
        res = ""
        count = 0
        for i in range(len(sn) - 1, -1, -1):
            res = res + sn[i]
            count = count + 1
            if count == 3 and i != 0:
                res = res + '.'
                count = 0
        return res[::-1]

26.
Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "Mr Ding"
Output: "rM gniD"

Mode: Easy

class Solution(object):
    def reverseWords(self, s):
        words = s.split()
        reversed_word = []
        for i in words:
            reversed_word.append(i[::-1])
        result = " ".join(reversed_word)
        return result

27.
Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

Example 1:

Input: word1 = ["ab", "c"], word2 = ["a", "bc"]
Output: true
Explanation:
word1 represents string "ab" + "c" -> "abc"
word2 represents string "a" + "bc" -> "abc"
The strings are the same, so return true.
Example 2:

Input: word1 = ["a", "cb"], word2 = ["ab", "c"]
Output: false
Example 3:

Input: word1  = ["abc", "d", "defg"], word2 = ["abcddefg"]
Output: true

Mode: Easy

class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        temp_word1 = ""
        temp_word2 = ""
        for i in word1:
            temp_word1 = temp_word1 + i
        for j in word2:
            temp_word2 = temp_word2 + j
        if temp_word1 == temp_word2:
            return True
        else:
            return False

        # return ''.join(word1) == ''.join(word2)
        # or
        # return "".join(word1) == "".join(word2)
        # or
        # return ''.join([ch for ch in word1]) == ''.join([ch for ch in word2])
        # or 
        # arrayStringsAreEqual = lambda self, w1, w2: ''.join(w1) == ''.join(w2)

28.
Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

Example 1:

Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
Example 2:

Input: num = 0
Output: 0

Mode: Easy

class Solution(object):
    def addDigits(self, num):
        if num == 0:
            return 0
        else:
            return 1 + (num - 1) % 9
# There is a formula for digital root in number theory which is to sum up all the digits till it's a single digit number

29.
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. 

Example 1:

Input: nums = [1,2,3,1]

Output: true

Explanation:

The element 1 occurs at the indices 0 and 3.

Example 2:

Input: nums = [1,2,3,4]

Output: false

Explanation:

All elements are distinct.

Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]

Output: true

Mode: Easy

class Solution(object):
    def containsDuplicate(self, nums):
        a = Counter(nums)
        for char, freq in a.items():
            if freq > 1:
                return True
        return False

30.
Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
 
Example 1:

Input: columnTitle = "A"
Output: 1
Example 2:

Input: columnTitle = "AB"
Output: 28
Example 3:

Input: columnTitle = "ZY"
Output: 701

Mode: Easy

class Solution(object):
    def titleToNumber(self, columnTitle):
        result = 0
        for char in columnTitle:
            result = result * 26 + (ord(char) - ord('A') + 1)
        return result

31.
Given a date string in the form Day Month Year, where:

Day is in the set {"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}.
Month is in the set {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}.
Year is in the range [1900, 2100].
Convert the date string to the format YYYY-MM-DD, where:

YYYY denotes the 4 digit year.
MM denotes the 2 digit month.
DD denotes the 2 digit day.

Example 1:

Input: date = "20th Oct 2052"
Output: "2052-10-20"
Example 2:

Input: date = "6th Jun 1933"
Output: "1933-06-06"
Example 3:

Input: date = "26th May 1960"
Output: "1960-05-26"
 
Constraints:

The given dates are guaranteed to be valid, so no error handling is necessary.

Mode: Easy

class Solution(object):
    def reformatDate(self, date):
        dates = {"Jan":"01",
                 "Feb":"02",
                 "Mar":"03",
                 "Apr":"04",
                 "May":"05",
                 "Jun":"06",
                 "Jul":"07",
                 "Aug":"08",
                 "Sep":"09",
                 "Oct":"10",
                 "Nov":"11",
                 "Dec":"12"}
        day, month, year = date.split()
        day = day[:-2].zfill(2)
        return "{}-{}-{}".format(year, dates[month], day)

32.
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.
Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.

Mode: Easy

class Solution(object):
    def romanToInt(self, s):
        roman_map = {'I':1,
                     'V':5,
                     'X':10,
                     'L':50,
                     'C':100,
                     'D':500,
                     'M':1000}
        total = 0
        prev_value = 0

        for char in reversed(s):  # iterating from right to left
            value = roman_map[char]
            if value < prev_value:
                total = total - value  # subtracting if smaller than previous (like IV or IX)
            else:
                total = total + value
                prev_value = value

        return total

33.
Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.

Note that the strings are case-insensitive, both lowercased and uppercased of the same letter are treated as if they are at the same row.

In the American keyboard:

the first row consists of the characters "qwertyuiop",
the second row consists of the characters "asdfghjkl", and
the third row consists of the characters "zxcvbnm".

Example 1:

Input: words = ["Hello","Alaska","Dad","Peace"]

Output: ["Alaska","Dad"]

Explanation:

Both "a" and "A" are in the 2nd row of the American keyboard due to case insensitivity.

Example 2:

Input: words = ["omk"]

Output: []

Example 3:

Input: words = ["adsdf","sfd"]

Output: ["adsdf","sfd"]

Mode: Easy

class Solution(object):
    def findWords(self, words):
        row1 = set("qwertyuiop")
        row2 = set("asdfghjkl")
        row3 = set("zxcvbnm")
        
        result = []
        for word in words:
            lower_word = word.lower()
            if set(lower_word).issubset(row1) or set(lower_word).issubset(row2) or set(lower_word).issubset(row3):
                result.append(word)
        return result

34.
Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.

You must implement a solution with a linear runtime complexity and use only constant extra space.

Example 1:

Input: nums = [2,2,3,2]
Output: 3
Example 2:

Input: nums = [0,1,0,1,0,1,99]
Output: 99

Mode: Easy

class Solution(object):
    def singleNumber(self, nums):
        s = Counter(nums)
        for char, freq in s.items():
            if freq == 1:
                return char

35.
Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

Example 1:

Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
Example 2:

Input: nums = [-1,0]
Output: [-1,0]
Example 3:

Input: nums = [0,1]
Output: [1,0]

Mode: Easy

class Solution(object):
    def singleNumber(self, nums):
        s = Counter(nums)
        temp = []
        for char, freq in s.items():
            if freq == 1:
                temp.append(char)
        return temp

36.
Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist.

An alphanumeric string is a string consisting of lowercase English letters and digits.

Example 1:

Input: s = "dfa12321afd"
Output: 2
Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2.
Example 2:

Input: s = "abc1111"
Output: -1
Explanation: The digits that appear in s are [1]. There is no second largest digit.

Mode: Easy

class Solution(object):
    def secondHighest(self, s):
        digits = set()

        for char in s:
            if char.isdigit():
                digits.add(int(char))

        if len(digits) < 2: # Means there is no second largest number
            return -1 

        return sorted(digits, reverse=True)[1]

37.
Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. 

Example 1:

Input: date = "2019-01-09"
Output: 9
Explanation: Given date is the 9th day of the year in 2019.
Example 2:

Input: date = "2019-02-10"
Output: 41

Mode: Easy

from datetime import datetime
class Solution(object):
    def dayOfYear(self, date):
        datetime1 = datetime.strptime(date, "%Y-%m-%d") # Converts string input to datetime format which is given inside the function
        return datetime1.timetuple().tm_yday # Returns the sequence of day in the year

38.
Given a string s of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.

Example 1:

Input: s = "leEeetcode"
Output: "leetcode"
Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".
Example 2:

Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
Example 3:

Input: s = "s"
Output: "s"

Mode: Easy

class Solution(object):
    def makeGood(self, s):
        res = []
        i = 0
        while i < len(s):
            if res and abs(ord(res[-1]) - ord(s[i])) == 32:
                res.pop()  # canceling out the bad pair
            else:
                res.append(s[i])
            i = i + 1
        return "".join(res)

39.
Given a 32-bit integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used.

All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.

Note: You are not allowed to use any built-in library method to directly solve this problem.

Example 1:

Input: num = 26
Output: "1a"
Example 2:

Input: num = -1
Output: "ffffffff"

Mode: Easy

class Solution(object):
    def toHex(self, num):
        if num == 0:
            return "0"

        hexchars = "0123456789abcdef"
        result = ""

        if num < 0:
            num = num + 2 ** 32
        
        while num > 0:
            digit = num % 16
            result = hexchars[digit] + result
            num = num // 16

        return result

40.
Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty. 

Example 1:

Input: s = "ab#c", t = "ad#c"
Output: true
Explanation: Both s and t become "ac".
Example 2:

Input: s = "ab##", t = "c#d#"
Output: true
Explanation: Both s and t become "".
Example 3:

Input: s = "a#c", t = "b"
Output: false
Explanation: s becomes "c" while t becomes "b".

Mode: Easy

class Solution(object):
    def backspaceCompare(self, s, t):
        def build(string):
            result = []
            for char in string:
                if char != '#':
                    result.append(char)
                elif result:
                    result.pop()
            return result
        
        return build(s) == build(t)

41.
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

Example 3:

Input: s = "(]"

Output: false

Example 4:

Input: s = "([])"

Output: true

Example 5:

Input: s = "([)]"

Output: false

Mode: Easy

class Solution(object):
    def isValid(self, s):
        # Keep removing valid bracket pairs until none remain
        while '()' in s or '{}' in s or '[]' in s:
            s = s.replace('()', '')
            s = s.replace('{}', '')
            s = s.replace('[]', '')
        return not s  # If string is empty, it's valid

42.
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false

Mode: Easy

class Solution(object):
    def containsNearbyDuplicate(self, nums, k):
        seen = set()
        
        for i in range(len(nums)):
            if nums[i] in seen:
                return True
            seen.add(nums[i])
        
            if len(seen) > k:
                seen.remove(nums[i - k])

        return False

43.
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Example 1:

Input: nums = [3,0,1]

Output: 2

Explanation:

n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

Example 2:

Input: nums = [0,1]

Output: 2

Explanation:

n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]

Output: 8

Explanation:

n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

Mode: Easy

class Solution(object):
    def missingNumber(self, nums):
        n = len(nums)
        actual_sum = sum(nums)
        expected_sum = (n * (n + 1)) // 2
        return expected_sum - actual_sum

44.
Given two binary strings a and b, return their sum as a binary string.

Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"

Mode: Easy

class Solution:
    def addBinary(self, a, b):
        return bin(int(a, 2) + int(b, 2))[2:]

45.
Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

Example 1:

Input: s = "egg", t = "add"

Output: true

Explanation:

The strings s and t can be made identical by:

Mapping 'e' to 'a'.
Mapping 'g' to 'd'.
Example 2:

Input: s = "foo", t = "bar"

Output: false

Explanation:

The strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.

Example 3:

Input: s = "paper", t = "title"

Output: true

Mode: Easy

class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False
    
        s_to_t = {}
        mapped_chars = set()
        
        for c1, c2 in zip(s, t):
            if c1 not in s_to_t:
                if c2 in mapped_chars:
                    # c2 is already mapped to another char in s
                    return False
                s_to_t[c1] = c2
                mapped_chars.add(c2)
            else:
                if s_to_t[c1] != c2:
                    return False
        return True

46.
Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]

Mode: Easy

# 841 ms which is very inefficient
class Solution(object):
    def moveZeroes(self, nums):
        for i in nums:
            if i == 0:
                nums.remove(i)
                nums.append(i)
        return nums

# Efficient one
class Solution(object):
    def moveZeroes(self, nums):
        non_zeros_pos = 0
        for i in nums:
            if i != 0:
                nums[non_zeros_pos] = i
                non_zeros_pos += 1

        for i in range(non_zeros_pos, len(nums)):
            nums[i] = 0

47.
Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.

Example 1:

Input: nums = [3,2,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2.
The third distinct maximum is 1.
Example 2:

Input: nums = [1,2]
Output: 2
Explanation:
The first distinct maximum is 2.
The second distinct maximum is 1.
The third distinct maximum does not exist, so the maximum (2) is returned instead.
Example 3:

Input: nums = [2,2,3,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2 (both 2's are counted together since they have the same value).
The third distinct maximum is 1.

Mode: Easy

class Solution(object):
    def thirdMax(self, nums):
        temp = []
        for i in nums:
            if i not in temp:
                temp.append(i)

        sortednums = sorted(temp)
        reversenums = sortednums[::-1]
        
        if len(reversenums) >= 3:
            return reversenums[2] # Third largest
        else:
            return max(reversenums)

48.
Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

Example 1:

Input: n = 1
Output: true
Explanation: 20 = 1
Example 2:

Input: n = 16
Output: true
Explanation: 24 = 16
Example 3:

Input: n = 3
Output: false

Mode: Easy

class Solution(object):
    def isPowerOfTwo(self, n):
        if n <= 0:
            return False
        while n % 2 == 0:
            n = n // 2
        if n == 1:
            return True
        else:
            return False

49.
Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.

Example 1:

Input: n = 27
Output: true
Explanation: 27 = 33
Example 2:

Input: n = 0
Output: false
Explanation: There is no x where 3x = 0.
Example 3:

Input: n = -1
Output: false
Explanation: There is no x where 3x = (-1).

Mode: Easy

class Solution(object):
    def isPowerOfThree(self, n):
        if n < 1:
            return False

        while n % 3 == 0:
            n = n // 3

        if n == 1:
            return True
        else:
            return False

50.
Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

Example 1:

Input: n = 16
Output: true
Example 2:

Input: n = 5
Output: false
Example 3:

Input: n = 1
Output: true

Mode: Easy

class Solution(object):
    def isPowerOfFour(self, n):
        if n < 1:
            return False

        while n % 4 == 0:
            n = n // 4

        if n == 1:
            return True
        else: 
            return False

51.
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

Mode: Easy

class Solution(object):
    def intersection(self, nums1, nums2):
        len_nums1 = len(nums1)
        len_nums2 = len(nums2)
        temp = []

        if len_nums1 > len_nums2:
            for i in nums2:
                if i in nums1:
                    temp.append(i)
            temp = list(set(temp))
            return temp

        if len_nums1 < len_nums2:
            for j in nums1:
                if j in nums2:
                    temp.append(j)
            temp = list(set(temp))
            return temp    

        if len_nums1 == len_nums2:
            for k in nums1:
                if k in nums2:
                    temp.append(k)
            temp = list(set(temp))
            return temp

Or 

class Solution(object):
    def intersection(self, nums1, nums2):
        return list(set(nums1) & set(nums2)) # '&' performs intersection

52.
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.

Mode: Easy

from collections import Counter

class Solution(object):
    def intersect(self, nums1, nums2):
        count1 = Counter(nums1)
        count2 = Counter(nums2)
        result = []

        for num in count1:
            if num in count2:
                # Adding the number min(count in both)
                result.extend([num] * min(count1[num], count2[num]))
        
        return result

53.
You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.

Example 1:

Input: nums = [1,2,2,4]
Output: [2,3]
Example 2:

Input: nums = [1,1]
Output: [1,2]

Mode: Easy

class Solution(object):
    def findErrorNums(self, nums):
        n = len(nums)
    
        # Step 1: Finding duplicate
        seen = set()
        duplicate = -1
        for num in nums:
            if num in seen:
                duplicate = num
            seen.add(num)

        # Step 2: Finding missing using math (optimal O(1) extra space)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        missing = expected_sum - (actual_sum - duplicate)
        
        return [duplicate, missing]

54.
Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]

Mode: Easy

class Solution(object):
    def findDisappearedNumbers(self, nums):
        nums_set = set(nums) # Taking a list and converting it into a set
        result = []
        l = len(nums)
        for i in range(1, l+1):
            if i not in nums_set:
                result.append(i)
        return result

55.
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

Mode: Easy

class Solution(object):
    def searchInsert(self, nums, target):
        for i in nums:
            if i == target:
                return nums.index(i)
            elif target not in nums:
                nums.append(target)
                nums.sort()
                return nums.index(target)

class Solution(object):
    def searchInsert(self, nums, target):
        nums.append(target)         # O(1)
        nums.sort()                 # O(n log n)
        return nums.index(target)   # O(n)

56.
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
Example 2:

Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
Example 3:

Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

Mode: Easy

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        nums1[m:] = nums2
        nums1.sort()

57.
Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

Example 1:

Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].

Example 2:

Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]

Mode: Easy

class Solution(object):
    def sortedSquares(self, nums):
        temp = []
        for i in nums:
            temp.append(i * i)
        temp.sort()
        return temp

58.Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.

Example 1:

Input: nums = [1,2,2,3,1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
Example 2:

Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation: 
The degree is 3 because the element 2 is repeated 3 times.
So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.

Mode: Easy

from collections import Counter

class Solution(object):
    def findShortestSubArray(self, nums):
        # step 1: counting frequency
        count = Counter(nums)
        degree = max(count.values())
        
        # step 2: tracking first and last index
        first, last = {}, {}
        for i, num in enumerate(nums):
            if num not in first:
                first[num] = i
            last[num] = i
        
        # step 3: finding min length among numbers with max frequency
        min_len = float('inf')
        for num in count:
            if count[num] == degree:
                min_len = min(min_len, last[num] - first[num] + 1)
        
        return min_len

59.
Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
 
Example 1:

Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.
Example 2:

Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.

Mode: Easy

class Solution(object):
    def mySqrt(self, x):
        if x < 2:
            return x

        left = 0
        right = x
        while left <= right:
            mid = (left + right) // 2
            if mid * mid == x:
                return mid
            elif mid * mid < x:
                ans = mid   # storing candidate
                left = mid + 1
            else:
                right = mid - 1
        return ans

60.
An array is monotonic if it is either monotone increasing or monotone decreasing.

An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].

Given an integer array nums, return true if the given array is monotonic, or false otherwise.

Example 1:

Input: nums = [1,2,2,3]
Output: true
Example 2:

Input: nums = [6,5,4,4]
Output: true
Example 3:

Input: nums = [1,3,2]
Output: false

Mode: Easy

class Solution(object):
    def isMonotonic(self, nums):
        sort_asc = sorted(nums)
        sort_desc = sorted(nums, reverse=True)
        if nums == sort_asc:
            return True
        if nums == sort_desc:
            return True
        else:
            return False

61.
Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.

Example 1:

Input: words = ["bella","label","roller"]
Output: ["e","l","l"]
Example 2:

Input: words = ["cool","lock","cook"]
Output: ["c","o"]

Mode: Easy

class Solution(object):
    def commonChars(self, words):
        temp = Counter(words[0])
        for i in words[1:]:
            temp = temp & Counter(i) # Keeping minimum frequency across all the words
        return list(temp.elements())

62.
Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

Example 1:

Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
Example 2:

Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]

Mode: Easy

class Solution(object):
    def transpose(self, matrix):
        transpose = []
        for j in range(len(matrix[0])):
            new_row = []
            for i in range(len(matrix)):
                new_row.append(matrix[i][j])
            transpose.append(new_row)
        return transpose

63.
Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.

The words in paragraph are case-insensitive and the answer should be returned in lowercase.

Note that words can not contain punctuation symbols.

Example 1:

Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
Example 2:

Input: paragraph = "a.", banned = []
Output: "a"

Mode: Easy

class Solution(object):
    def mostCommonWord(self, paragraph, banned):
        # Step 1: replacing punctuation with spaces
        for ch in "!?',;.":
            paragraph = paragraph.replace(ch, " ")
        
        # Step 2: splitting into lowercase words
        words = paragraph.lower().split()

        # Step 3: converting banned to set
        banned_set = set(banned)

        # Step 4: counting using dictionary
        counts = {}
        for word in words:
            if word not in banned_set:
                counts[word] = counts.get(word, 0) + 1

        # Step 5: returning the word with max count
        return max(counts, key=counts.get)

64.
Given a valid (IPv4) IP address, return a defanged version of that IP address.

A defanged IP address replaces every period "." with "[.]".

Example 1:

Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Example 2:

Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"

Mode: Easy

class Solution(object):
    def defangIPaddr(self, address):
        return address.replace(".", "[.]")

65.
You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once for each word in words).

Return the sum of lengths of all good strings in words.

Example 1:

Input: words = ["cat","bt","hat","tree"], chars = "atach"
Output: 6
Explanation: The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
Example 2:

Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
Output: 10
Explanation: The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.

Mode: Easy

class Solution(object):
    def countCharacters(self, words, chars):
        chars_cnt = Counter(chars)
        total_len = 0

        for word in words:
            word_cnt = Counter(word)
            if all(word_cnt[c] <= chars_cnt[c] for c in word_cnt):
                total_len = total_len + len(word)
        return total_len

66.
Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

Example 1:

Input: nums = [3,1,2,4]
Output: [2,4,3,1]
Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
Example 2:

Input: nums = [0]
Output: [0]

Mode: Easy

class Solution(object):
    def sortArrayByParity(self, nums):
        even = []
        odd = []
        for i in nums:
            if i % 2 == 0:
                even.append(i)
            else:
                odd.append(i)
        return even + odd

67.
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, "Hello World", "HELLO", and "hello world hello world" are all sentences.
You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.

 

Example 1:

Input: s = "Hello how are you Contestant", k = 4
Output: "Hello how are you"
Explanation:
The words in s are ["Hello", "how" "are", "you", "Contestant"].
The first 4 words are ["Hello", "how", "are", "you"].
Hence, you should return "Hello how are you".
Example 2:

Input: s = "What is the solution to this problem", k = 4
Output: "What is the solution"
Explanation:
The words in s are ["What", "is" "the", "solution", "to", "this", "problem"].
The first 4 words are ["What", "is", "the", "solution"].
Hence, you should return "What is the solution".
Example 3:

Input: s = "chopper is not a tanuki", k = 5
Output: "chopper is not a tanuki"

Mode: Easy

class Solution(object):
    def truncateSentence(self, s, k):
        spl = s.split()
        return " ".join(spl[:k])

68.
Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.

You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

You may also assume each line in the text file must not contain leading or trailing white spaces.

Example:

Assume that file.txt has the following content:

987-123-4567
123 456 7890
(123) 456-7890
Your script should output the following valid phone numbers:

987-123-4567
(123) 456-7890

Mode: Easy

grep -E '^([0-9]{3}-[0-9]{3}-[0-9]{4}|\([0-9]{3}\) [0-9]{3}-[0-9]{4})$' file.txt

69.
Given a string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

Example 1:

Input: s = "abab"
Output: true
Explanation: It is the substring "ab" twice.
Example 2:

Input: s = "aba"
Output: false
Example 3:

Input: s = "abcabcabcabc"
Output: true
Explanation: It is the substring "abc" four times or the substring "abcabc" twice.
 
Mode: Easy

class Solution(object):
    def repeatedSubstringPattern(self, s):
        doubled = (s + s)
        sub = doubled[1:-1]
        return s in sub

70.
Given a text file file.txt, print just the 10th line of the file.

Example:

Assume that file.txt has the following content:

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Your script should output the tenth line, which is:

Line 10
Note:
1. If the file contains less than 10 lines, what should you output?
2. There's at least three different solutions. Try to explore all possibilities.

Mode: Easy

awk 'NR == 10' file.txt

71.
An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.

Given an integer n, return true if n is an ugly number.

Example 1:

Input: n = 6
Output: true
Explanation: 6 = 2 × 3
Example 2:

Input: n = 1
Output: true
Explanation: 1 has no prime factors.
Example 3:

Input: n = 14
Output: false
Explanation: 14 is not ugly since it includes the prime factor 7.

Mode: Easy

class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        for p in [2, 3, 5]:
            while n % p == 0:
                n = n // p
            
        if n == 1:
            return True
        else:
            return False

72.
A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.

Given an integer n, return true if n is a perfect number, otherwise return false.

Example 1:

Input: num = 28
Output: true
Explanation: 28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, and 14 are all divisors of 28.
Example 2:

Input: num = 7
Output: false

Mode: Easy

class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num <= 1:
            return False
        
        total = 1 

        i = 2
        while i * i <= num:
            if num % i == 0:
                total += i
                if i != num // i:
                    total += num // i
            i += 1

        return total == num

73.
Given an integer array nums, find three numbers whose product is maximum and return the maximum product.

Example 1:

Input: nums = [1,2,3]
Output: 6
Example 2:

Input: nums = [1,2,3,4]
Output: 24
Example 3:

Input: nums = [-1,-2,-3]
Output: -6

Mode: Easy

class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        product1 = nums[-1] * nums[-2] * nums[-3]
        product2 = nums[0] * nums[1] * nums[-1]
        return max(product1,product2)

74.
Given an integer number n, return the difference between the product of its digits and the sum of its digits.

Example 1:

Input: n = 234
Output: 15 
Explanation: 
Product of digits = 2 * 3 * 4 = 24 
Sum of digits = 2 + 3 + 4 = 9 
Result = 24 - 9 = 15
Example 2:

Input: n = 4421
Output: 21
Explanation: 
Product of digits = 4 * 4 * 2 * 1 = 32 
Sum of digits = 4 + 4 + 2 + 1 = 11 
Result = 32 - 11 = 21

Mode: Easy

class Solution:
    def subtractProductAndSum(self, n: int) -> int:
        product = 1
        sum = 0
        num = list(str(n))
        for i in num:
            product = product * int(i)
        for j in num:
            sum = sum + int(j)
        return product - sum

75.
Given an array nums of integers, return how many of them contain an even number of digits.

Example 1:

Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
Example 2:

Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.

Mode: Easy

class Solution:
    def findNumbers(self, nums: List[int]) -> int:
        count = 0
        for i in nums:
            if len(str(i)) % 2 == 0:
                count = count + 1
        return count

76.
Implement a function signFunc(x) that returns:

1 if x is positive.
-1 if x is negative.
0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.

Return signFunc(product).

Example 1:

Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1
Example 2:

Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0
Example 3:

Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1

Mode: Easy

class Solution:
    def arraySign(self, nums: List[int]) -> int:
        product = 1
        for i in nums:
            product = product * i
        if product == 0:
            return 0
        if product < 0:
            return -1
        if product > 0:
            return 1

77.
Reversing an integer means to reverse all its digits.

For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.
Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.

Example 1:

Input: num = 526
Output: true
Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.
Example 2:

Input: num = 1800
Output: false
Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.
Example 3:

Input: num = 0
Output: true
Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num.

Mode: Easy

class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        reversed1 = int(str(num)[::-1])
        reversed2 = int(str(reversed1)[::-1])
        return reversed2 == num

78.
You are given two non-negative integers num1 and num2.

In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.

For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.
Return the number of operations required to make either num1 = 0 or num2 = 0.

Example 1:

Input: num1 = 2, num2 = 3
Output: 3
Explanation: 
- Operation 1: num1 = 2, num2 = 3. Since num1 < num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1.
- Operation 2: num1 = 2, num2 = 1. Since num1 > num2, we subtract num2 from num1.
- Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1.
Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations.
So the total number of operations required is 3.
Example 2:

Input: num1 = 10, num2 = 10
Output: 1
Explanation: 
- Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0.
Now num1 = 0 and num2 = 10. Since num1 == 0, we are done.
So the total number of operations required is 1.

Mode: Easy

class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count_operation = 0
        while num1 > 0 and num2 > 0:
            if num1 >= num2:
                num1 = num1 - num2
            else:
                num2 = num2 - num1
            count_operation += 1
        return count_operation

79.
Given two integers num1 and num2, return the sum of the two integers.

Example 1:

Input: num1 = 12, num2 = 5
Output: 17
Explanation: num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.
Example 2:

Input: num1 = -10, num2 = 4
Output: -6
Explanation: num1 + num2 = -6, so -6 is returned.

Mode: Easy

class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2

80.
You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.

You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].

Return the array ans. Answers within 10-5 of the actual answer will be accepted.

Note that:

Kelvin = Celsius + 273.15
Fahrenheit = Celsius * 1.80 + 32.00

Example 1:

Input: celsius = 36.50
Output: [309.65000,97.70000]
Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.
Example 2:

Input: celsius = 122.11
Output: [395.26000,251.79800]
Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798.

Mode: Easy

class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        Kelvin = celsius + 273.15
        Fahrenheit = celsius * 1.80 + 32.00
        return [Kelvin, Fahrenheit]

81.
Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.

Return an integer denoting the sum of all numbers in the given range satisfying the constraint.

Example 1:

Input: n = 7
Output: 21
Explanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.
Example 2:

Input: n = 10
Output: 40
Explanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.
Example 3:

Input: n = 9
Output: 30
Explanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30.

Mode: Easy

class Solution:
    def sumOfMultiples(self, n: int) -> int:
        sum = 0
        for i in range(1, n+1):
            if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
                sum = sum + i
        return sum

82.
You are given an integer n that consists of exactly 3 digits.

We call the number n fascinating if, after the following modification, the resulting number contains all the digits from 1 to 9 exactly once and does not contain any 0's:

Concatenate n with the numbers 2 * n and 3 * n.
Return true if n is fascinating, or false otherwise.

Concatenating two numbers means joining them together. For example, the concatenation of 121 and 371 is 121371.

Example 1:

Input: n = 192
Output: true
Explanation: We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.
Example 2:

Input: n = 100
Output: false
Explanation: We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.

Mode: Easy

class Solution:
    def isFascinating(self, n: int) -> bool:
        double_n = 2 * n
        triple_n = 3 * n
        merging = int(str(n) + str(double_n) + str(triple_n))
        pairs = Counter(str(merging))
        return pairs == Counter("123456789")

83.
An integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.

Example 1:

Input: x = 18

Output: 9

Explanation:

The sum of digits of x is 9. 18 is divisible by 9. So 18 is a Harshad number and the answer is 9.

Example 2:

Input: x = 23

Output: -1

Explanation:

The sum of digits of x is 5. 23 is not divisible by 5. So 23 is not a Harshad number and the answer is -1.

Mode: Easy

class Solution:
    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        strx = str(x)
        sum = 0
        for i in strx:
            sum = sum + int(i)
        if x % sum == 0:
            return sum
        else:
            return -1

84.
In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual.

As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.

Example 1:

Input: nums = [0,1,1,0]

Output: [0,1]

Explanation:

The numbers 0 and 1 each appear twice in the array.

Example 2:

Input: nums = [0,3,2,1,3,2]

Output: [2,3]

Explanation:

The numbers 2 and 3 each appear twice in the array.

Example 3:

Input: nums = [7,1,5,4,3,4,6,0,9,5,8,2]

Output: [4,5]

Explanation:

The numbers 4 and 5 each appear twice in the array.

Mode: Easy

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        check = Counter(nums)
        temp = []
        for char, freq in check.items():
            if freq == 2:
                temp.append(char)
        return temp

85.
You are given an integer array nums.

You replace each element in nums with the sum of its digits.

Return the minimum element in nums after all replacements.

Example 1:

Input: nums = [10,12,13,14]

Output: 1

Explanation:

nums becomes [1, 3, 4, 5] after all replacements, with minimum element 1.

Example 2:

Input: nums = [1,2,3,4]

Output: 1

Explanation:

nums becomes [1, 2, 3, 4] after all replacements, with minimum element 1.

Example 3:

Input: nums = [999,19,199]

Output: 10

Explanation:

nums becomes [27, 10, 19] after all replacements, with minimum element 10.

Mode: Easy

class Solution:
    def minElement(self, nums: List[int]) -> int:
        temp = []
        for i in nums:
            digitsum = sum(int(j) for j in str(i))
            temp.append(digitsum)
        sorting = sorted(temp)
        return sorting[0]

86.
You are given a positive integer n.

Return the maximum product of any two digits in n.

Note: You may use the same digit twice if it appears more than once in n.

Example 1:

Input: n = 31

Output: 3

Explanation:

The digits of n are [3, 1].
The possible products of any two digits are: 3 * 1 = 3.
The maximum product is 3.
Example 2:

Input: n = 22

Output: 4

Explanation:

The digits of n are [2, 2].
The possible products of any two digits are: 2 * 2 = 4.
The maximum product is 4.
Example 3:

Input: n = 124

Output: 8

Explanation:

The digits of n are [1, 2, 4].
The possible products of any two digits are: 1 * 2 = 2, 1 * 4 = 4, 2 * 4 = 8.
The maximum product is 8.

Mode: Easy

class Solution:
    def maxProduct(self, n: int) -> int:
        digits = sorted([int(d) for d in str(n)], reverse=True)
        return digits[0] * digits[1]

87.
You are given an integer array nums.

Return true if the frequency of any element of the array is prime, otherwise, return false.

The frequency of an element x is the number of times it occurs in the array.

A prime number is a natural number greater than 1 with only two factors, 1 and itself. 

Example 1:

Input: nums = [1,2,3,4,5,4]

Output: true

Explanation:

4 has a frequency of two, which is a prime number.

Example 2:

Input: nums = [1,2,3,4,5]

Output: false

Explanation:

All elements have a frequency of one.

Example 3:

Input: nums = [2,2,2,4,4]

Output: true

Explanation:

Both 2 and 4 have a prime frequency.

Mode: Easy

class Solution:
    def checkPrimeFrequency(self, nums: List[int]) -> bool:
        from collections import Counter

        def is_prime(n):
            if n <= 1:
                return False
            for i in range(2, n):
                if n % i == 0:
                    return False
            return True

        freq = Counter(nums)

        for f in freq.values():
            if is_prime(f):   # if any frequency is prime
                return True

        return False

88.
Given an integer n, find the digit that occurs least frequently in its decimal representation. If multiple digits have the same frequency, choose the smallest digit.

Return the chosen digit as an integer.

The frequency of a digit x is the number of times it appears in the decimal representation of n. 

Example 1:

Input: n = 1553322

Output: 1

Explanation:

The least frequent digit in n is 1, which appears only once. All other digits appear twice.

Example 2:

Input: n = 723344511

Output: 2

Explanation:

The least frequent digits in n are 7, 2, and 5; each appears only once.

Mode: Easy

class Solution:
    def getLeastFrequentDigit(self, n: int) -> int:
        check = Counter(str(n))
        min_freq = min(check.values())
        temp = []
        for char, freq in check.items():
            if freq == min_freq:
                temp.append(char)
        answer = sorted(temp)
        return int(answer[0])

89.
You are given a positive integer n.

Return the integer obtained by removing all zeros from the decimal representation of n.

Example 1:

Input: n = 1020030

Output: 123

Explanation:

After removing all zeros from 1020030, we get 123.

Example 2:

Input: n = 1

Output: 1

Explanation:

1 has no zero in its decimal representation. Therefore, the answer is 1.

Mode: Easy

class Solution:
    def removeZeros(self, n: int) -> int:
        return int(str(n).replace("0", ""))

90.
Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.

Return the largest lucky integer in the array. If there is no lucky integer return -1.

Example 1:

Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Example 2:

Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
Example 3:

Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.

Mode: Easy

class Solution:
    def findLucky(self, arr: List[int]) -> int:
        cntr = Counter(arr)
        lucky = -1

        for char, freq in cntr.items():
            if char == freq:
                lucky = max(lucky, char)

        return lucky

91.
You are given a string s consisting of lowercase English letters ('a' to 'z').

Your task is to:

Find the vowel (one of 'a', 'e', 'i', 'o', or 'u') with the maximum frequency.
Find the consonant (all other letters excluding vowels) with the maximum frequency.
Return the sum of the two frequencies.

Note: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.

The frequency of a letter x is the number of times it occurs in the string.
 
Example 1:

Input: s = "successes"

Output: 6

Explanation:

The vowels are: 'u' (frequency 1), 'e' (frequency 2). The maximum frequency is 2.
The consonants are: 's' (frequency 4), 'c' (frequency 2). The maximum frequency is 4.
The output is 2 + 4 = 6.
Example 2:

Input: s = "aeiaeia"

Output: 3

Explanation:

The vowels are: 'a' (frequency 3), 'e' ( frequency 2), 'i' (frequency 2). The maximum frequency is 3.
There are no consonants in s. Hence, maximum consonant frequency = 0.
The output is 3 + 0 = 3.

Mode: Easy

class Solution:
    def maxFreqSum(self, s: str) -> int:
        vowels = {'a','e','i','o','u'}
        vowels1 = []
        consonants1 = []
        for i in list(s):
            if i in vowels:
                vowels1.append(i)
            else:
                consonants1.append(i)

        ctr_vowels = Counter(vowels1)
        ctr_consonants = Counter(consonants1)

        max_vowel = max(ctr_vowels.values()) if ctr_vowels else 0
        max_consonant = max(ctr_consonants.values()) if ctr_consonants else 0

        return max_vowel + max_consonant
